= Lab3 - Evolving services with Serverless
:experimental:

In our cloud-native application architecture, We now have multiple microservices in a *reactive* system. However, it’s not necessary that applications and services remain up and running 24 hours day. They only need to be running *on-demand*, when something needs to use the service. This is one of the reasons why *serverless* architectures have gained popularity.

* *Serverless* is often used interchangeably with the term _FaaS_ (Functions-as-a-Service). But serverless doesn’t mean that there is no server. In fact, there _are_ servers - a public cloud provider provides the servers that deploy, run, and manage your application.
* *Serverless computing* is an emerging category that represents a shift in the way developers build and deliver software systems. Abstracting application infrastructure away from the code can greatly simplify the development process while introducing new cost and efficiency benefits. Serverless computing and FaaS will play an important role in helping to define the next era of enterprise
IT, along with cloud-native services and the https://enterprisersproject.com/hybrid-cloud[hybrid cloud^].
* *Serverless platforms* provide APIs that allow users to run code snippets (functions, also called _actions_) and return the results of each function. Serverless platforms also provide endpoints to allow the developer to retrieve function results. These endpoints can be used as inputs for other functions, thereby providing a sequence (or chain) of related functions.

The severless application enables DevOps teams to enjoy benefits like:

* Optimizing computing resources(i.e CPU, Memory)
* Autoscaling
* Simplifying CI/CD pipeline

=== Goals of this lab

The goal is to develop serverless applications on *Red Hat Runtimes* and deploy them on *OpenShift 4* using https://www.openshift.com/learn/topics/serverless[OpenShift Serverless^] with a cloud-native, continuous integration and delivery (CI/CD) Pipelines. In this lab, we’ll deploy the Payment Service as a Quarkus-based serverless application using Knative Serving, Istio, and Tekton
Pipelines. After this lab, you should end up with something like:

image::lab3-goal.png[goal, 700]

The Knative Kafka Event _source_ enables _Knative Eventing_ integration with Apache Kafka. When a message is produced in Apache Kafka, the Apache Kafka Event Source will consume the produced message and post that message to the corresponding event _sink_.

==== What is Red Hat OpenShift Serverless?

OpenShift Serverless helps developers to deploy and run applications that will scale up or scale to zero on-demand. Applications are packaged as OCI compliant Linux containers that can be run anywhere.

image::knative-serving-diagram.png[knative, 800]

Applications can be triggered by a variety of event sources, such as events from your own applications, cloud services from multiple providers, Software as a Service (SaaS) systems and Red Hat Services (https://access.redhat.com/products/red-hat-amq[AMQ Streams^]).

image::knative-eventing-diagram.png[knative, 800]

OpenShift Serverless applications can be integrated with other OpenShift services, such as OpenShift https://www.openshift.com/learn/topics/pipelines[Pipelines^], https://www.openshift.com/learn/topics/service-mesh[Service Mesh^], Monitoring and https://github.com/operator-framework/operator-metering[Metering^], delivering a complete serverless application development and deployment experience.

=== 1. Building a Native Executable

Let’s now produce a native executable for an example Quarkus application. It improves the startup time of the application, and produces a minimal disk and memory footprint, which is important in serverless applications. The executable would have everything to run the application including the `JVM`(shrunk to be just enough to run the application), and the application. This is accomplished using https://graalvm.org/[GraalVM^].

`GraalVM` is a universal virtual machine for compiling and running applications written in JavaScript, Python, Ruby, R, JVM-based languages like Java, Scala, Groovy, Kotlin, Clojure, and LLVM-based languages such as C and C++. It includes ahead-of-time compilation, aggressive dead code elimination, and optimal packaging as native binaries that moves a lot of startup logic to build-time, thereby reducing startup time and memory resource requirements significantly.

image::native-image-process.png[serverless, 700]

`GraalVM` is already installed for you. Inspect the value of the `GRAALVM_HOME` variable in the CodeReady Workspaces Terminal
with:

[source,sh,role="copypaste"]
----
echo $GRAALVM_HOME
----

In this step, we will learn how to compile the application to a native executable and run the native image on local machine.

Compiling a native image takes longer than a regular JAR file (bytecode) compilation. However, this compilation time is only incurred once, as opposed to every time the application starts, which is the case with other approaches for building and executing JARs.

Let’s find out why Quarkus calls itself _SuperSonic Subatomic Subatomic Java_. Let’s build a sample app. In CodeReady Terminal, run this command:

[source,sh,role="copypaste"]
----
mkdir /tmp/hello && cd /tmp/hello && \
mvn io.quarkus:quarkus-maven-plugin:1.7.5.Final-redhat-00007:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DplatformGroupId=com.redhat.quarkus \
    -DplatformVersion=1.7.5.Final-redhat-00007 \
    -DclassName="org.acme.quickstart.GreetingResource" \
    -Dpath="/hello"
----

This will create a simple Quarkus app in the */tmp/hello* directory.

Next, create a `native executable` with this command:

[source,sh,role="copypaste"]
----
mvn -f /tmp/hello/getting-started/pom.xml clean package -Pnative -DskipTests -Dquarkus.native.native-image-xmx=2g
----

This may take a minute or two to run. One of the benefits of Quarkus is amazingly fast startup time, at the expense of a longer build time to optimize and remove dead code, process annotations, etc. This is only incurred once, at build time rather than _every_ startup!

[NOTE]
====
Since we are on Linux in this environment, and the OS that will eventually run our application is also Linux, we can use our local OS to build the native Quarkus app. If you need to build native Linux binaries when on other OS’s like Windows or Mac OS X, you’ll need to have Docker installed and then use `mvn clean package -Pnative -Dnative-image.docker-build=true -DskipTests=true`.
====

image::payment-native-image-build.png[serverless, 700]

The output of the native build is a native Linux binary, which you can see using the `readelf` command. Run this in a Terminal:

[source,sh,role="copypaste"]
----
readelf -h /tmp/hello/getting-started/target/*-runner
----

you'll see

[source,console]
----
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  ....
----

It's a binary that can only run on Linux, but as you'll see in a moment, this native executable starts up _very_ fast and takes up little memory.

Since our environment here is Linux, you can just run it. In the CodeReady Workspaces Terminal, run:

[source,sh,role="copypaste"]
----
/tmp/hello/getting-started/target/*-runner
----

[WARNING]
====
If you still have a previous application running in a separate CodeReady Terminal, you may get an error like `java.net.BindException: Address already in use`. Go to that other tab and press kbd:[CTRL+C] to stop the previous application, then try to run the native application again!
====

Notice the amazingly fast startup time:

[source,shell]
----
__  ____  __  _____   ___  __ ____  ______ 
 --/ __ \/ / / / _ | / _ \/ //_/ / / / __/ 
 -/ /_/ / /_/ / __ |/ , _/ ,< / /_/ /\ \   
--\___\_\____/_/ |_/_/|_/_/|_|\____/___/   
2020-10-22 01:57:51,424 INFO  [io.quarkus] (main) getting-started 1.0-SNAPSHOT native (powered by Quarkus x.x.x) started in 0.016s. Listening on: http://0.0.0.0:8080
2020-10-22 01:57:51,424 INFO  [io.quarkus] (main) Profile prod activated. 
2020-10-22 01:57:51,424 INFO  [io.quarkus] (main) Installed features: [cdi, resteasy]
----

That’s *16 milliseconds* to start up. The start-up time might be different in your environment.

And extremely low memory usage as reported by the Linux `ps` utility. While the app is running, run the following command in another Terminal:

[source,sh,role="copypaste"]
----
ps -o pid,rss,command -p $(pgrep -f runner)
----

You should see something like:

[source,shell]
----
    PID   RSS COMMAND
   4506 61024 /tmp/hello/getting-started/target/getting-started-1.0-SNAPSHOT-runner
----

This shows that our process is taking around 61MB of memory (https://en.wikipedia.org/wiki/Resident_set_size[Resident Set
Size^], or RSS). Pretty compact!

[NOTE]
====
The RSS and memory usage of any app, including Quarkus, will vary depending your specific environment, and will rise as the application experiences load.
====

Make sure the app works. In a new CodeReady Workspaces Terminal run:

[source,sh,role="copypaste"]
----
curl -i http://localhost:8080/hello
----

You should see the return:

[source,console]
----
HTTP/1.1 200 OK
Content-Length: 5
Content-Type: text/plain;charset=UTF-8

hello
----

*Congratulations!* You’ve now built a Java application as a native executable JAR and a Linux native binary. We’ll explore the benefits of native binaries later in when we start deploying to Kubernetes.

Be sure to terminate the running Quarkus development via kbd:[CTRL+C]).

=== 2. Delete old payment service

_OpenShift Serverless_ builds on Knative Serving to support deploying and serving of serverless applications and functions. _Serverless_ is easy to get started with and scales to support advanced scenarios.

The OpenShift Serverless provides middleware primitives that enable:

* Rapid deployment of serverless containers
* Automatic scaling up and down to zero
* Routing and network programming for Istio components
* Point-in-time snapshots of deployed code and configurations

In the lab, _OpenShift Serverless Operator_ is already installed on your OpenShift 4 cluster but if you want to install it on your
own OpenShift cluster, follow https://docs.openshift.com/container-platform/latest/serverless/installing-openshift-serverless.html[Installing OpenShift Serverless^].

First, we need to delete existing `BuildConfig` as it is based an excutable Jar that we deployed it in the previous lab.

[source,sh,role="copypaste"]
----
oc delete bc/payment imagestream.image.openshift.io/payment
----

We also will delete our existing payment _deployment_ and _route_ since Knative will handle deploying the payment service and routing traffic to its managed pod when needed. Delete the existing payment deployment and its associated route and service with:

[source,sh,role="copypaste"]
----
oc delete dc/payment route/payment svc/payment
----

=== 3. Enable Knative Eventing integration with Apache Kafka Event

_Knative Eventing_ is a system that is designed to address a common need for cloud native development and provides composable primitives to enable `late-binding` event sources and event consumers with below goals:

* Services are loosely coupled during development and deployed independently.
* Producer can generate events before a consumer is listening, and a consumer can express an interest in an event or class of events that is not yet being produced.
* Services can be connected to create new applications without modifying producer or consumer, and with the ability to select a specific subset of events from a particular producer.

The _Apache Kafka Event source_ enables Knative Eventing integration with Apache Kafka. When a message is produced to Apache Kafka, the Event Source will consume the produced message and post that message to the corresponding event sink.

Remove direct Knative integration code. Currently our Payment service directly binds to Kafka to listen for events. Now that we have Knative eventing integration, we no longer need this code. Open the `PaymentResource.java` file (in `payment-service/src/main/java/com/redhat/cloudnative` directory).

Comment out the `onMessage()` method via kbd:[CTRL+/] (or kbd:[Command+/] on Mac OS):

[source,java]
----
//    @Incoming("orders")
//    public CompletionStage<Void> onMessage(KafkaRecord<String, String> message)
//            throws IOException {
//
//        log.info("Kafka message with value = {} arrived", message.getPayload());
//        handleCloudEvent(message.getPayload());
//        return message.ack();
//    }
----

And delete the configuration for the incoming stream. In `application.properties`, comment out the following lines for the _Incoming_ stream and _OpenShift extension_ via kbd:[CTRL+/] (or kbd:[Command+/] on Mac OS):

[source,none]
----
# OpenShift extension
# quarkus.kubernetes-client.trust-certs=true
# quarkus.container-image.build=true
# quarkus.kubernetes.deploy=true
# quarkus.kubernetes.deployment-target=openshift
# quarkus.openshift.expose=true
# quarkus.openshift.labels.app.openshift.io/runtime=quarkus
# quarkus.s2i.base-jvm-image=registry.access.redhat.com/ubi8/openjdk-11

...

# Incoming stream (unneeded when using Knative events)
# mp.messaging.incoming.orders.connector=smallrye-kafka
# mp.messaging.incoming.orders.value.deserializer=org.apache.kafka.common.serialization.StringDeserializer
# mp.messaging.incoming.orders.key.deserializer=org.apache.kafka.common.serialization.StringDeserializer
# mp.messaging.incoming.orders.bootstrap.servers=my-cluster-kafka-bootstrap:9092
# mp.messaging.incoming.orders.group.id=payment-order-service
# mp.messaging.incoming.orders.auto.offset.reset=earliest
# mp.messaging.incoming.orders.enable.auto.commit=true
# mp.messaging.incoming.orders.request.timeout.ms=30000
----

[WARNING]
====
Make sure you only comment out or delete the lines starting with `mp.messaging.incoming`, `OpenShift extension` and leave the rest!
====

Then append the following configuration for native compilation using `Mandrel` builder image:

[source,properties,role="copypaste"]
----
quarkus.container-image.group={{ USER_ID }}-cloudnativeapps// <1>
quarkus.container-image.registry=image-registry.openshift-image-registry.svc:5000
quarkus.kubernetes-client.trust-certs=true
quarkus.kubernetes.deployment-target=knative// <2>
quarkus.kubernetes.deploy=true
quarkus.native.native-image-xmx=4g// <3>
quarkus.openshift.expose=true
----

<1> Define a project name where you deploy a serverless application
<2> Enable the generation of Knative resources
<3> Mximum Java heap to be used during the native image generation

[NOTE]
====
Mandrel is a downstream distribution of the GraalVM community edition. Mandrel's main goal is to provide a native-image release specifically to support https://access.redhat.com/documentation/en-us/red_hat_build_of_quarkus[Quarkus^]. The aim is to align the native-image capabilities from GraalVM with OpenJDK and Red Hat Enterprise Linux libraries to improve maintainability for native Quarkus applications.
====

In order to complie a native binary, Let's remove a specified package type(i.e. uberJar) configuration in `pom.xml`. Open the _pom.xml_ then remove or comment the following configuration option:

image::remove-uberjar.png[serverless, 900]

Rebuild and re-deploy new payment service via running the following maven plugin in CodeReady Workspaces Terminal:

[source,sh,role="copypaste"]
----
mvn clean package -Pnative -DskipTests -f $CHE_PROJECTS_ROOT/cloud-native-workshop-v2m4-labs/payment-service
----

The _-Pnative_ argument selects the native maven profile which invokes the _Graal compiler_. It will take a few minutes(up to 7 mins) to complete a native binary build as well as deploying a new knative service. After successful creation of the service we should see a *Knative Service*(_KSVC_) and *Revision*(_REV_) in the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View]:

[NOTE]
====
It will take a few moments (up to 30 seconds) to fully render while the networking is setup properly. Try reloading the browser page if all you see is an empty box!
====

Let's edit labels to add _Quarkus_ icon. Previously you did this with a series of `oc label` commands, but let's do it once manually just for fun. Click on payment *REV* then select *Edit Labels* in _Actions_ drop box:

image::kservice-up.png[serverless, 700]

Add this label and click on *Save*:

[source,sh,role="copypaste"]
----
app.openshift.io/runtime=quarkus
----

image::quarkus-label.png[serverless, 500]

Now you see Quarkus icon in _Payment Service_ on topology:

image::kservice-up-quarkus.png[serverless, 700]

In the lab environment, _OpenShift Serverless_ will automatically scale services down to zero instances when the service(i.e. payment) has no request after *30 seconds* which means the payment service pod will unavailable in 30 seconds. Visit again the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^]. Ensure there's no *blue circle* in the payment service!

[NOTE]
====
You need to wait ~30 seconds before it scales to 0!
====

image::kservice-down.png[serverless, 700]

If you send traffic to this endpoint it will trigger the autoscaler to scale the app up. Click on http://payment-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN }}[Open URL^] to _trigger_ the payment service. This will send some dummy data to the `payment` service, but more importantly it triggered knative to spin up the pod again automatically, and will shut it down 30 seconds later.

image::payment-serving-magic.png[serverless, 700]

*Congratulations!* You’ve now deployed the payment service as a Quarkus native image, served with _OpenShift Serverless_, quicker than traditional Java applications. This is not the end of Serverless capabilites so we will now see how the payment service will scale up _magically_ in the following exercises.

Let's move on to create *KafkaSource* to enable *Knative Eventing*. In this lab, _Knative Eventing_ is already installed via the _Knative Eventing Operator_ in OpenShift 4 cluster.

Back on the {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^], click on `+` icon on the right top corner.

image::plus-icon.png[serverless, 500]

Copy the following `KafkaSource` in `YAML` editor then click on *Create*:

[source,yaml,role="copypaste"]
----
apiVersion: sources.knative.dev/v1beta1
kind: KafkaSource
metadata:
  name: kafka-source
spec:
  consumerGroup: knative-group
  bootstrapServers:
  - my-cluster-kafka-bootstrap.{{ USER_ID }}-cloudnativeapps:9092
  topics:
  - orders
  sink:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: payment
----

You can see a new connection between Kafka and our *payments* service:

[NOTE]
====
Serverless is an advanced and still evolving feature, and in this case you may not see the `KafkaSource` represented on the Topology view depending on the version of OpenShift and OpenShift serverless in use. If it does not appear, do not worry! The underlying technology will work as expected, so simply continue on.
====

image::kafka-event-source-link.png[serverless, 700]

*Great job!* Let’s make sure if the payment service works properly with _Serverless_ features via Coolstore Web UI.

=== 4. End to End Functional Testing

Before getting started, we need to make sure if _payment service_ is scaled down to _zero_ again in {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^]:

image::payment-down-again.png[serverless, 700]

Let’s go shopping! Access the http://coolstore-ui-{{ USER_ID }}-cloudnativeapps.{{ ROUTE_SUBDOMAIN}}[Red Hat Cool Store^]!

Add some cool items to your shopping cart in the following shopping scenarios:

[arabic]
. Add a _Pronounced Kubernetes_ to your cart by click on *Add to Cart*. You will see the `Success! Added!` message under the top menu.

image::add-to-cart-serverless.png[serverless, 1000]

[arabic, start=2]
. Go to the *Cart* tab and click on the *Checkout* button . Input the credit card information. The Card Info should be 16 digits and begin with the digit `4`. For example `4123987754646678`.

image::checkout-serverless.png[serverless, 1000]

[arabic, start=3]
. Input your Credit Card information to pay for the items:

image::input-cc-info-serverless.png[serverless, 1000]

[arabic, start=4]
. Let’s find out how _Kafka Event_ enables _Knative Eventing_. Go back to {{ CONSOLE_URL }}/topology/ns/{{ USER_ID }}-cloudnativeapps[Topology View^] then confirm if *payment service* is up automatically. It’s `MAGIC!!`

image::payment-serving-magic.png[serverless, 500]

[arabic, start=5]
. Confirm the _Payment Status_ of the your shopping items in the *All Orders* tab. It should be `Processing`.

image::payment-processing-serverless.png[serverless, 1000]


[arabic, start=5]
. After a few moments, reload the *Orders* page to confirm that the Payment Status changed to `COMPLETED` or `FAILED`.

[NOTE]
====
If the status is still *Processing*, the order service is processing incoming Kafka messages and store them in MongoDB. Please reload the page a few times more.
====

image::payment-completedorfailed-serverless.png[serverless, 1000]

This is the same result as before, but using Knative eventing to make a more powerful event-driven system that can scale with demand.

=== Summary

In this module, we learned how to develop cloud-native applications using multiple Java runtimes (Quarkus and Spring Boot), Javascript (Node.js) and different datasources (i.e. PostgreSQL, MongoDB) to handle a variety of business use cases which implement real-time _request/response_ communication using REST APIs, event-driven/reactive shopping cart service using Apache Kafka in _Red Hat AMQ Streams_.

Next, we converted the payment service to be a *Serverless* application using _OpenShift Serverless_ with Knative.

To learn more about _OpenShift Serverless_ and Knative, continue on to the next section to go deeper into the different facets and capabilities of this technology.

==== Additional Resources:

* https://learn.openshift.com/developing-with-quarkus/[Quarkus Tutorials Right in Your Browser^]
* https://developers.redhat.com/articles/quarkus-quick-start-guide-kubernetes-native-java-stack/[Quarkus Quickstart Guide]
* https://docs.openshift.com/container-platform/latest/serverless/serverless-getting-started.html[Getting started with OpenShift Serverless^]
* https://www.openshift.com/learn/topics/pipelines[Cloud-native CI/CD on OpenShift^]
* https://developers.redhat.com/topics/serverless-architecture/[Serverless Architecture Articles^]
